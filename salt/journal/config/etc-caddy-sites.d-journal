{% if pillar.journal.get('default_host') %}
    {% set public_host = pillar.journal.get('default_host') %}
{% elif salt['elife.only_on_aws']() %}
    {% set public_host = salt['elife.cfg']('project.full_hostname') %}
{% else %}
    {% set public_host = 'dev--journal.elifesciences.org' %}
{% endif %}

{% if salt['elife.only_on_aws']() %}
    {% set public_scheme = 'https' %}
{% else %}
    {% set public_scheme = 'http' %}
{% endif %}

{# subdomain => canonical-domain+path redirects #}
{% for subdomain, redirect_path in pillar.journal.get('subdomain_redirects', {}).items() %}
{{ subdomain }}.{{ pillar.elife.domain }}:80 {% if public_scheme == "https" %}{{ subdomain }}.{{ pillar.elife.domain }}:443 {% endif %}{
    {% if public_scheme == 'https' %}
    import ../snippets/certs
    {% endif %}
    {% if redirect_path %}
    redir {{ public_scheme }}://{{ public_host }}{{ redirect_path }}
    {% else %}
    redir {{ public_scheme }}://{{ public_host }}{uri}
    {% endif %}
}
{% endfor %}


# what are these?
# 'map' sticks the 'X-Forwarded-Host' value into a variable called 'robots_disallow',
# which is used in a sort switch/case statement.
# if the 'X-Forwarded-Host' header value matches the regex, then 'robots_disallow' equals an empty string ("")
# if the 'X-Forwarded-Host' header value does not match, it uses the default value of "/".

# in this particular case, the intent is to serve up dynamic /robots.txt content.
# if the request originated from an upstream proxy, like our CDN, then the final value is empty (""),
# resulting in an empty (and probably invalid) "Disallow: " statement.
# otherwise, we get a "Disallow: /" statement, forbidding robots to crawl the content.
# this can be tested with "curl -H 'X-Forwarded-Host: elifesciences.org' localhost/robots.txt"
#map $http_x_forwarded_host $robots_disallow {
#    default "/";
#    "~^(?<first_host>(?:[^,]+\.)?{{ pillar.elife.domain|regex_escape }})\s*(?:,|$)" "";
#}

# in this case, the intent is to capture the first of possibly multiple hostnames and pass it to FastCGI
# as the definitive X_FORWADED_HOST value.
#map $http_x_forwarded_host $http_x_forwarded_host_filtered {
#    default "";
#    "~^(?<first_host>(?:[^,]+\.)?{{ pillar.elife.domain|regex_escape }})\s*(?:,|$)" $first_host;
#}

(config) {

    {% if salt['elife.only_on_aws']() %}
        redir protocol http to https://{{ pillar.elife.domain }}{uri}
    {% endif %}

    {# todo: mass redirects are useful in general. lets find a way of supporting this that isn't elife-specific #}
    import ../snippets/redirect-existing-paths

    log {
        output file /var/log/caddy/access.log
        format json {
            time_format rfc3339
        }
    }

    import ../snippets/fixed-response-paths
    import ../snippets/robots

    respond 404

}

:80 {
    import config
}

{% if public_scheme == 'https' %}
:443 {
    import ../snippets/certs
    import config
}
{% endif %}

